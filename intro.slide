Go for Beginners
Semana da Computação UFRJ
20 Sep 2017

André Carvalho
Developer, Globo.com
asantostc@gmail.com
http://andrestc.com
@andresantostc

* License and Materials

This presentation is licensed under the [[https://creativecommons.org/licenses/by-sa/4.0/][Creative Commons Attribution-ShareAlike 4.0 International]] licence.

The materials for this presentation are available on GitHub:

.link https://github.com/andrestc/go-workshop-101

You are encouraged to remix, transform, or build upon the material, providing you give appropriate credit and distribute your contributions under the same license.

If you have suggestions or corrections to this presentation, please raise [[https://github.com/andrestc/go-workshop-101/issues][an issue on the GitHub project]].

* License and Materials

This slide deck is based contains some slides from:

.link https://github.com/davecheney/introduction-to-go/ Dave Cheney, Introduction to Go.

.link https://talks.golang.org/2014/taste.slide Robert Griesemer, A Taste of Go.

* Agenda

The following topics will be covered in this workshop:

- Language
- Concurrency
- Coding!

* Language

* Introduction

- Modern
- Compact, concise, general-purpose
- Imperative, statically type-checked, dynamically type-safe
- Garbage-collected
- Compiles to native code, statically linked
- Fast compilation, efficient execution
- Great support for concurrency!

* Hello, Go!

Let's write our first Go program.

.play -edit src/hello/hello.go

Feel free to edit the message and re-run the code.

* Exercise

- Create a directory ~/go/src/github.com/<your-name>/go-workshop/hello
- Type in the "Hello World!" code from last slide
- Use the go tool to run/build/install your code
	go run
	go build
	go install

- go run compiles and run your code
- go build compiles from scratch and outputs the binary to the current directory
- go install compiles and outputs the binary to the ~/go/bin/

* Language

In this section we will cover most of the Go syntax with some examples.

We will cover:

- Variables, constants, types, pointers
- Statements
- Functions, methods
- Slices, maps
- Interfaces

* Constants

- Maintained precisely:
	const e = 2.71828182845904523536028747135266249775724709369995957496696763
	const third = 1.0/3
- Typed or without type:
	const M64 int64 = 1<<20
        const M = 1<<20
- Evaluated at compile-time:
	const big = 1<<100 / 1e30  // valid constant expression

Compiler complains if a constant doesn't fit where it is _used_.

* Variables

- Statically typed:
	var x int
	var s, t string
- Implicitly or explicitly initialized:
	var x int
	var s, t string = "foo", "bar"  // multiple assignment

	var x = 42                      // int
	var s, b = "foo", true          // string, bool
- Short variable declaration (inside functions only):
	x := 42
	s, b := "foo", true
- Can safely take address of _any_ variable!
	return &x
# compiler will do the right thing

* Types

- Predeclared types, the usual suspects:
	uint8 (byte), uint16, uint32, uint32, uint64,
	int8, int16, int32, int32 (rune), int64,
	float32, float64,
	complex64, complex128,
	uint, int, uintptr,
	bool, string,
	error  // not so usual

- Composite types:
	array, struct, pointer, function,
	slice, map, channel

- Abstract type:
	interface

* Type declarations

- Composition from left-to-right (Pascal style):
	[10]byte  // array of 10 bytes

	struct {
		name        string
		left, right *Node
		action      func(*Node)
	}

	func(a, b, c int)
	func(http.ResponseWriter, *http.Request) error

- A type declaration defines a _new_ type:
	type Weekday int

	type Point struct {
		x, y int
	}

* Statements

A _statement_ is a command to do something:

- _Declare_a_new_integer_variable_x_and_assign_it_the_value_10_.
- _Add_4_to_the_value_of_x_and_store_the_result_in_y_.
- _While_x_less_than_20_perform_these_statements_.

There are several kinds of statements in Go, we've seen a few already. The most common statements are:

- Declarations: `const`pi`=`3.14159265359`, `type`Counter`int32`, …
- Assignments: `count`=`count`+`1`, …
- Increment/Decrement: `x++`, `y--`
- Conditionals: `if`…`{`…`}`else`{`…`}`, `switch`{`…`}`
- Loops: `for`…`{`…`}`
- Control flow: `break`, `fallthrough`, `continue`, `goto`, `return`.

* Assignment

It is common that you need to change the value stored in a variable, this is called _Assignment_.

.play -edit src/assignment/assignment1/main.go /START OMIT/,/END OMIT/

In this example, we declare

- Press *Run* to check that program prints, `1`, `2`, `4`.
# - Update the program to declare a new variable, `z`, which has a value 2x larger than `y`.

* Assignment (cont.)

You can only assign a new value to _variables_.

.play -edit src/assignment/assignment2/main.go /START OMIT/,/END OMIT/

It is a syntax error to assign a new value to a constant.

- Press *Run* and see the program does not compile.
- Edit the sample code to change the declaration of `x` from a constant (`const`) to a variable (`var`).
- Press *Run* and check the program compiles and prints the correct answer, 2.

* Increment and decrement

Go supports a limited form of variable post-increment and post-decrement, ie. `x++`, `x--`.

.play -edit src/increment/increment1/main.go /START OMIT/,/END OMIT/

- Press *Run* and see the program prints `2`,
- Edit the sample code to subtract `1` from `i` using the decrement operator `i--`.
- Press *Run* and check the program compiles and prints the correct answer, 0.

* Increment and decrement (cont.)

`i++` and `i--` are _statements_, not an _expressions_, they do not produce a value.

.play -edit src/increment/increment2/main.go /START OMIT/,/END OMIT/

This program has a syntax error. 

- Edit the sample code to correct the error by moving the `i++` statement above the declaration of `var`j`.
- Press *Run* and check the program compiles and prints the correct answer, 2, 2.

* Looping

Go has a single `for` loop construct that combines

- `while` _condition_ `{`…`}`
- `do`{`…`}`while` _condition_
- `do`{`…`}`until` _condition_

into one syntax.

- `for` _(init_statement)_; _condition_; _(post_statement)_ `{`…`}`

The parts of a `for` statement are:

- init statement: used to initalise the loop variable; `i`=`0`.
- condition: user to test if the loop is done; `i`<`10`, `true` means keep looping.
- post statement: user to increment the loop variable; `i++`, `i`=`i`-`1`.

* Looping (cont.) 

Let's practice using loops.

.play -edit src/loops/loops1/main.go /START OMIT/,/END OMIT/

This program counts from `1` to `10`, can you make it print only the _even_ numbers.

- Edit the program to make it print only the even numbers between `1` and `10`, inclusive.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

_note_: you do not need to put `(` braces around the `for` condition `)`. In fact, if you do it's a syntax error. Try it.

* Looping (cont.) 

Let's practice counting down, this is where you would use a `while` loop in other languages.

.play -edit src/loops/loops2/main.go /START OMIT/,/END OMIT/

This program counts down from `10` to `1`, can you make it count from `7` to `3`.

- Edit the program to make it print only the numbers from `7` down to `3`.
- Press *Run* and check the program compiles and prints the correct answer, `7`, `6`, `5`, `4`, `3`.

_note_: this `for` loop only has a _condition_, there is no _init_statement_ or _post_statement_, so we can omit the semicolons, `;`.

* Conditional statements

Go has two conditional statements, `if` and `switch`.

`if` is used to choose between two choices based on a _condition_.

 if v > 0 {
         println("v is greater than zero")
 } else {
         println("v is less than or equal to zero")
 }

In some cases the body of the `else` block may be omitted. This is very common when checking preconditions in a method of a function.

 if v == 0 {
         // nothing to do
         return
 }
 // handle v

* if

Let's revisit our previous even numbers `for` loop example.

.play -edit src/conditionals/conditionals1/main.go /START OMIT/,/END OMIT/

This program counts from `1` to `10`, can you make it print only the _even_ numbers.

- Uncomment the `if`i%2`==`0`{` and `}` lines to make the program print only the even numbers between `1` and `10`.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

_note_: `%` is the _modulo_ operator in Go. All even numbers divide wholly by `2`, leaving `0` as their _modulo_ (or remainder).

* continue

Unlike languages like Java, `if` statements in Go are often used as _guard_clauses_.

We say that when everything is true the code reads from the top to the bottom of the page.

We can rewrite the previous program using a new statement, `continue`, which _skips_ the body of the loop.

.play -edit src/conditionals/conditionals2/main.go /START OMIT/,/END OMIT/

- Uncomment the `if`i%1`==`1`{`, `continue`, and `}` lines.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

* break

This program is an _infinite_loop_. There is no _condition_expression_ in the `for` loop.

We can use the `break` statement, which breaks out of the _current_ loop, to fix it.

.play -edit src/conditionals/conditionals3/main.go /START OMIT/,/END OMIT/

- Uncomment the `if`i`>`10`{`, `break`, and `}` lines.
- Press *Run* and check the program compiles and prints the correct answer, `2`, `4`, `6`, `8`, `10`.

* Functions

- Regular functions
	func Sin(x float64) float64
	func AddScale(x, y int, f float64) int

- Multiple return values
	func Write(data []byte) (written int, err error)

- Variadic parameter lists without magic
	func Printf(format string, args ...interface{})

- Functions are first-class values
	var delta int
	return func(x int) int { return x + delta }

* Methods

Methods are functions with a _receiver_ parameter:

.code src/point.go /String START/,/String END/

The receiver binds the method to its _base_type_ (Point):

.code src/point.go /Point START/,/Point END/

Methods are invoked via the usual dot notation:

.play src/point.go /main START/,/main END/

* Slices

	[]T  // slice of T

- Descriptor for an underlying array segment
- May grow and shrink
- Has length and capacity
- Assigning a slice copies the descriptor, not the underlying array

Common slice operations:

	len(s)
	s[i]
	s[i:j]
	append(s, x)  // append element x to slice s and return new slice

- Slices play the role of dynamically sized arrays
- Widely used in Go code


* Maps

	map[K]V  // map K -> V

- Map is a language-supplied hash table
- Maps values of key type K to values of type V
- Assigning a map copies the map reference, not the map contents

Common map operations:

	make(map[K]V)
	len(m)
	m[k]
	delete(m, k)

- Map iteration order is not specified:

	for key, value := range m {
		// order of key sequence different each time
	}

* Interface types

- Abstract
- Define (possibly empty) set of method signatures
- Values of _any_type_ that implement all methods of an interface can be assigned to a variable of that interface.

Examples:

	interface{}  // empty interface

	interface {
		String() string
	}

	interface {
		Len() int
		Swap(i, j int)
		Less(i, j int) bool
	}


* Using interfaces

.code src/stringer.go /Stringer START/,/Stringer END/

Both Weekday and Point define a String method, so values of both can be assigned to
a variable of Stringer type:

.play src/stringer.go /main START/,/main END/

Method calls via interface types are dynamically dispatched ("virtual function call").

* Concurrency

* Goroutines

- The _go_ statement launches a function call as a goroutine
	go f()
	go f(x, y, ...)

- A goroutine runs concurrently (but not necessarily in parallel)
- A goroutine has its own stack


* A simple example

.code src/concurrency1.go /f START/,/f END/

Function f is launched as 3 different goroutines, all running concurrently:

.play -edit src/concurrency1.go /main START/,/main END/

- Try removing time.Sleep from main(). What happened?

* Communication via channels

A channel type specifies a channel value type (and possibly a communication direction):

	chan int
	chan<- string  // send-only channel
	<-chan T       // receive-only channel

A channel is a variable of channel type:

	var ch chan int
	ch := make(chan int)  // declare and initialize with newly made channel

A channel permits _sending_ and _receiving_ values:

	ch <- 1   // send value 1 on channel ch
	x = <-ch  // receive a value from channel ch (and assign to x)

Channel operations synchronize the communicating goroutines.

* Communicating goroutines

Each goroutine sends its results via channel ch:

.code src/concurrency2.go /f START/,/f END/

The main goroutine receives (and prints) all results from the same channel:

.play -edit src/concurrency2.go /main START/,/main END/

- Try removing the go calls. What happened?


